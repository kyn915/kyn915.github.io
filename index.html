<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-选择器"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/%E9%80%89%E6%8B%A9%E5%99%A8/"
    >选择器</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/%E9%80%89%E6%8B%A9%E5%99%A8/" class="article-date">
  <time datetime="2021-01-26T12:59:52.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Post-author-￢-￢-智商三岁-￢-￢-智商三岁"><a href="#Post-author-￢-￢-智商三岁-￢-￢-智商三岁" class="headerlink" title="Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁"></a>Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁</h1><h1 id="Post-link-http-example-com-2021-01-26-css选择器"><a href="#Post-link-http-example-com-2021-01-26-css选择器" class="headerlink" title="Post link: http://example.com/2021/01/26/css选择器/"></a>Post link: <a href="http://example.com/2021/01/26/css%E9%80%89%E6%8B%A9%E5%99%A8/">http://example.com/2021/01/26/css选择器/</a></h1><h1 id="Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally"><a href="#Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally" class="headerlink" title="Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally."></a>Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally.</h1><h1 id="css-选择器"><a href="#css-选择器" class="headerlink" title="css 选择器"></a>css 选择器</h1><p>什么是选择器？</p>
<p>每一条css样式定义由两部分组成，形式如下：选择器{样式}，在{}之前的部分就是“选择器”。 “选择器”指明了{}中的“样式”的作用对象，也就是“样式”作用于网页中的哪些元素</p>
<h1 id="选择器有哪些"><a href="#选择器有哪些" class="headerlink" title="选择器有哪些"></a>选择器有哪些</h1><p>类选择器、标签选择器、ID选择器、后代选择器、子选择器、伪类选择器、通用选择器、群组选择器、相邻同胞选择器、属性选择器、伪元素选择器、结构性伪类选择器、UI元素状态伪类选择器等等。</p>
<h1 id="常用选择器使用方法"><a href="#常用选择器使用方法" class="headerlink" title="常用选择器使用方法"></a>常用选择器使用方法</h1><h1 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h1><p>类选择器根据类名来选择，前面以”.”来标志，如：.box{color:red;}</p>
<h1 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h1><p>一个完整的HTML页面是有很多不同的标签组成，而标签选择器，则是决定哪些标签<br>采用相应的CSS样式，如：p{color:red;}、 span{font-size:12px;}</p>
<h1 id="ID-选择器"><a href="#ID-选择器" class="headerlink" title="ID 选择器"></a>ID 选择器</h1><p>ID 选择器可以为标有特定 ID 的 HTML 元素指定特定的样式。 根据元素ID来选择元素，具有唯一性，这意味着同一id在同一文档页面中只能出现一次,前面以”#”号来标志，在样式里面可以这样定义：#demoDiv{color:red;}</p>
<h1 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h1><p>后代选择器也称为包含选择器，用来选择特定元素或元素组的后代，将对父元素的选择放在前面，对子元素的选择放在后面，中间加一个空格分开。后代选择器中的元素不仅仅只能有两个，对于多层祖先后代关系，可以有多个空格加以分开,如：.box p span{color:red;}  即box下p标签里的所有span颜色为red。</p>
<h1 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h1><p>请注意这个选择器与后代选择器的区别，子选择器（child selector）仅是指它的直接后代，或者你可以理解为作用于子元素的第一个后代。而后代选择器是作用于所有子后代元素。后代选择器通过空格来进行选择，而子选择器是通过“&gt;”进行选择，如：.box &gt; a {color:red;}。</p>
<p>子选择器（&gt;）和后代选择器（空格）的区别：<br>都表示“祖先-后代”的关系，但是&gt;必须是“爸爸&gt;儿子”，而空格不仅可以是“爸爸儿子”，还能是“爷爷儿”、“太爷爷儿子”。</p>
<h1 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h1><p>有时候需要用文档以外的其他条件来应用元素的样式，比如鼠标悬停等。这时候就需要用到伪类了。伪类常用于a标签。<br>如 ：a:link{<br>        color:#999999;<br>    }<br>    a:visited{<br>        color:#FFFF00;<br>    }<br>    a:hover{<br>        color:#006600;<br>    }<br>    a:active{<br>        color:#006600;<br>    }<br>    Link表示链接在没有被点击时的样式。Visited表示链接已经被访问时的样式。Hover表示当鼠标悬停在链接上面时的样式，active表示链接正在访问中时的样式。</p>
<h1 id="通用选择器"><a href="#通用选择器" class="headerlink" title="通用选择器"></a>通用选择器</h1><p>通用选择器用*来表示。例如：<br>    *{<br>        font-size: 12px;<br>    }</p>
<h1 id="群组选择器"><a href="#群组选择器" class="headerlink" title="群组选择器"></a>群组选择器</h1><p>当几个元素样式属性一样时，可以共同调用一个声明，元素之间用逗号分隔。如：<br>p, td, li {<br>    height:20px;<br>}<br>.box1 h1,.box2 h3,.box3 h2 {<br>    font-weight:100;<br>}<br>使用群组选择器，将会大大的简化CSS代码，将具有多个相同属性的元素，合并群组进行选择，定义同样的CSS属性，这大大的提高了编码效率，同时也减少了CSS文件的体积。</p>
<h1 id="相邻同胞选择器"><a href="#相邻同胞选择器" class="headerlink" title="相邻同胞选择器"></a>相邻同胞选择器</h1><p>除了上面的子选择器与后代选择器，可能还希望找到兄弟两个当中的一个，如一个标题h1元素后面紧跟了两个段落p元素，我们想定位第一个段落p元素，对它应用样式。我们就可以使用相邻同胞选择器。<br>如:<br>h1 + p {color:blue}</p>
<h1>一个非常专业的CSS站点</h1>
<p>Div+CSS教程中，介绍了很多关于CSS网页布局的知识。</p>
<p>CSS布局实例中，有很多与CSS布局有关的案例。</p>

<p>会看到第一个段落“Div+CSS教程中，介绍了很多关于CSS网页布局的知识。”文字颜色将会是蓝色。而第二段则不受此CSS样式的影响。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-观察者模式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"
    >观察者模式</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2021-01-26T12:56:43.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="Post-author-￢-￢-智商三岁-￢-￢-智商三岁"><a href="#Post-author-￢-￢-智商三岁-￢-￢-智商三岁" class="headerlink" title="Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁"></a>Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁</h1><h1 id="Post-link-http-example-com-2021-01-26-观察者模式"><a href="#Post-link-http-example-com-2021-01-26-观察者模式" class="headerlink" title="Post link: http://example.com/2021/01/26/观察者模式/"></a>Post link: <a href="http://example.com/2021/01/26/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">http://example.com/2021/01/26/观察者模式/</a></h1><h1 id="Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally"><a href="#Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally" class="headerlink" title="Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally."></a>Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally.</h1><h1 id="观察者模式是什么？"><a href="#观察者模式是什么？" class="headerlink" title="观察者模式是什么？"></a>观察者模式是什么？</h1><p>观察者模式（Observer Pattern）:定义对象之间的一种 一对多依赖关系，使得每当一个对象状态发生改变时，其他依赖对象皆得到通知并被自动更新。观察者模式是一种对象行为型模式。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>在一个抽象模型中，一个对象的行为 依赖于另一个对象的状态。即当目标对象的状态发生改变是，会直接影响到观察者的行为；<br>一个对象需要通知其他对象发生反应，但不知道对象是谁。<br>需要在系统中创建一个触发链时，A对象的行为将影响B，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p>
<h1 id="模式组成"><a href="#模式组成" class="headerlink" title="模式组成"></a>模式组成</h1><p>在观察着模式中，通常包含以下角色：</p>
<p>目标（Subject）</p>
<p>观察目标（ConcresteSubject）</p>
<p>观察者（Observer）</p>
<p>具体观察者（ConcreteObserver）</p>
<h1 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h1><p>观察者模式可以实现 表示层和数据逻辑层的分离，并降低观察目标和观察者之间的耦合度；<br>观察者模式支持简单广播通信，自动通知所有已经订阅过的对象；<br>观察者模式 符合开闭原则的要求；<br>观察目标和观察者之间的抽象耦合关系能够单独扩展以及中庸。</p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>当一个观察目标有多个直接或间接的观察者时，通知所有观察者的过程将会话费很多时间。<br>当观察目标和观察者之间存在循环依赖时，观察目标会触发他们之间进行循环调用，可能导致系统崩溃。<br>观察者模式缺少相应机制，让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-proxy整理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/26/proxy%E6%95%B4%E7%90%86/"
    >proxy整理</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/26/proxy%E6%95%B4%E7%90%86/" class="article-date">
  <time datetime="2021-01-26T00:59:51.000Z" itemprop="datePublished">2021-01-26</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-mvvm和mvc，mvp区别"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/23/mvvm%E5%92%8Cmvc%EF%BC%8Cmvp%E5%8C%BA%E5%88%AB/"
    >mvvm和mvc，mvp区别</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/23/mvvm%E5%92%8Cmvc%EF%BC%8Cmvp%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2021-01-23T13:45:16.000Z" itemprop="datePublished">2021-01-23</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>软件中最核心的，最基本的东西是什么? 是的，是数据。我们写的所有代码，都是围绕数据的。<br>围绕着数据的产生、修改等变化，出现了业务逻辑。<br>围绕着数据的显示，出现了不同的界面技术。 </p>
<p>没有很好设计的代码，常常就会出现数据层(持久层)和业务逻辑层还有界面代码耦合的情况。</p>
<p>ORM等框架，解耦合了业务逻辑和数据之间的耦合，业务逻辑不再关心底层数据如何存储和读取。所有数据呈现给业务逻辑层的就是一个个的对象。<br>而MVC, MVP, MMVM用来解决业务逻辑和视图之间的耦合。<br>MVC优点</p>
<p>由于MVC很好的分离了视图层和业务层，所以它具有以下优点<br>耦合性低<br>开发速度快<br>可维护性高<br>没有控件的概念，对html没有封装，易于理解<br>和其它平台(java, php)等更加相似。便于人才获取<br>MVP的优势</p>
<p>1、模型与视图完全分离，我们可以修改视图而不影响模型<br>2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部<br>3、我们可以将一个Presener用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。<br>4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户界面来测试这些逻辑（单元测试）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-虚拟dom是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/20/%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88/"
    >虚拟dom是什么</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/20/%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2021-01-20T13:39:22.000Z" itemprop="datePublished">2021-01-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>  在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。</p>
<pre><code>    虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。在实际开发中基本无需关心虚拟DOM是如何运作的，但是理解其运行机制不仅有助于更好的理解React组件的生命周期，而且对于进一步优化 React程序也会有很大帮助。</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-super关键字"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/19/super%E5%85%B3%E9%94%AE%E5%AD%97/"
    >super关键字</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/19/super%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-date">
  <time datetime="2021-01-19T13:34:42.000Z" itemprop="datePublished">2021-01-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>作用：</p>
<p>1<br>super 关键字用于访问父对象上的函数。<br>语法：</p>
<p>1<br>2<br>super([arguments]); // 访问父对象上的构造函数<br>super.functionOnParent([arguments]); // 访问对象上的方法<br>详解：</p>
<p>super可以用在类的继承中，或者对象字面量中，super指代了整个prototype或者__proto__指向的对象</p>
<p>1 类（prototype相关）</p>
<p>a 用在子类constructor函数中<br> class Person {<br>    constructor (name) {<br>      this.name = name;<br>    }<br>  }<br> class Student extends Person {<br>    constructor (name, age) {<br>      super(); // 用在构造函数中，必须在使用this之前调用<br>      this.age = age;<br>   }<br> }<br> super()调用会生成一个空对象，作为context来调用父类的constructor，返回this对象，作为子类constructor的context继续调用构造函数。</p>
<p>context：执行上下文 constructor：构造函数<br>b 调用父类的静态函数<br>class Human {<br>    constructor() {}<br>    static ping() {<br>      return ‘ping’;<br>    }<br>  }</p>
<p>  class Computer extends Human {<br>    constructor() {}<br>   static pingpong() {<br>     return super.ping() + ‘ pong’;<br>   } // 只有在子类的静态函数中才能调用父类的静态函数（babel环境测试，按理说，在实例函数中应该也可以调用，不过实际测试环境中报错）<br> }<br> Computer.pingpong(); // ‘ping pong’</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-原型链"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/18/%E5%8E%9F%E5%9E%8B%E9%93%BE/"
    >原型链</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/18/%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time datetime="2021-01-18T13:30:17.000Z" itemprop="datePublished">2021-01-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>套用一句很粗暴的话，所谓原型链就是找妈的一种行为方式，就可以理解为人是人他妈生的，妖是妖他妈生的。原型链的核心其实就只有一个：属性共享和独立的控制，当你的对象实例需要独立的属性，所有做法的本质都是在对象实例里面创建属性。若不考虑太多，你大可以在Person里面直接定义你所需要独立的属性来覆盖掉原型的属性。总之，使用原型继承的时候，要对于原型中的属性要特别注意，因为他们都是牵一发而动全身的存在。现在最常用的方法是组合模式。</p>
<p>1、原型链</p>
<h1 id="简单理解就是原型组成的链，对象的-proto-它的是原型，而原型也是一个对象，也有-proto-属性，原型的-proto-又是原型的原型，就这样可以一直通过-proto-想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。"><a href="#简单理解就是原型组成的链，对象的-proto-它的是原型，而原型也是一个对象，也有-proto-属性，原型的-proto-又是原型的原型，就这样可以一直通过-proto-想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。" class="headerlink" title="简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。"></a>简单理解就是原型组成的链，对象的__proto__它的是原型，而原型也是一个对象，也有__proto__属性，原型的__proto__又是原型的原型，就这样可以一直通过__proto__想上找，这就是原型链，当向上找找到Object的原型的时候，这条原型链就算到头了。</h1><pre><code>1）构造函数、原型和实例的关系

    ①构造函数都有一个属性prototype，这个属性是一个对象（Object的实例）
    ②原型对象prototype里面有一个constructor属性，该属性指向原型对象所属的构造函数
    ③实例对象都有一个_proto_属性，该属性也指向构造函数的原型对象，它是一个非标准属性，不可以用于编程，它是用于浏览器自己使用的
2）prototype与_proto_的关系


    ①prototype是构造函数的属性

    ②_proto_是实例对象的属性

                ——这两者都指向同一个对象

【总结】i）函数也是对象，对象不一定是函数；

        ii）对象的本质：无序的键值对集合；键值对当中的值可以是任意数据类型的值

        iii）对象就是一个容器，这个容器当中放的是（属性和方法）</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-key的作用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/key%E7%9A%84%E4%BD%9C%E7%94%A8/"
    >key的作用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/key%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2021-01-17T15:35:33.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>最常见的是结合 v-for 使用</p>
<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<p>完整地触发组件的生命周期钩子<br>触发过渡<br><transition><br>    <span :key="text"></span><br></transition><br>当text发生改变时，<span>总是会被替换而不是被修改，因此会引发过渡</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-TCP和UDP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/TCP%E5%92%8CUDP/"
    >TCP和UDP</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/TCP%E5%92%8CUDP/" class="article-date">
  <time datetime="2021-01-17T15:30:34.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p>
<p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。<br>网络层：负责路由以及把分组报文发送给目标网络或主机。<br>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。<br>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</p>
<p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h1 id="UDP-是什么？"><a href="#UDP-是什么？" class="headerlink" title="UDP 是什么？"></a>UDP 是什么？</h1><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><p>（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</p>
<p>（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>
<p>（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</p>
<p>（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</p>
<p>（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</p>
<p>（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p>
<h1 id="Post-author-￢-￢-智商三岁-￢-￢-智商三岁"><a href="#Post-author-￢-￢-智商三岁-￢-￢-智商三岁" class="headerlink" title="Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁"></a>Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁</h1><h1 id="Post-link-http-example-com-2021-01-13-TCP和UDP以及三次握手"><a href="#Post-link-http-example-com-2021-01-13-TCP和UDP以及三次握手" class="headerlink" title="Post link: http://example.com/2021/01/13/TCP和UDP以及三次握手/"></a>Post link: <a href="http://example.com/2021/01/13/TCP%E5%92%8CUDP%E4%BB%A5%E5%8F%8A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">http://example.com/2021/01/13/TCP和UDP以及三次握手/</a></h1><h1 id="Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally"><a href="#Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally" class="headerlink" title="Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally."></a>Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally.</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h1 id="TCP-提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用-4-次握手来关闭一个连接。"><a href="#TCP-提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用-4-次握手来关闭一个连接。" class="headerlink" title="TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次握手来关闭一个连接。"></a>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次握手来关闭一个连接。</h1><h1 id="三次握手建立一个连接"><a href="#三次握手建立一个连接" class="headerlink" title="三次握手建立一个连接"></a>三次握手建立一个连接</h1><p>三次握手的过程:</p>
<p>第一次握手</p>
<p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br>第二次握手</p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br>第三次握手</p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p>
<h1 id="四次握手关闭一个连接"><a href="#四次握手关闭一个连接" class="headerlink" title="四次握手关闭一个连接"></a>四次握手关闭一个连接</h1><p>第一次握手</p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br>第二次握手</p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br>第三次握手</p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br>第四次握手</p>
<p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-new"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/new/"
    >new</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/new/" class="article-date">
  <time datetime="2021-01-17T15:24:34.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>new<br>JavaScript深入之new的模拟实现</p>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
<p>模拟 new 之前，先看看 new 实现了哪些功能。<br>例子：</p>
<p>// Otaku 御宅族，简称宅<br>function Otaku (name, age) {<br>    this.name = name;<br>    this.age = age;</p>
<pre><code>this.habit = &#39;Games&#39;;</code></pre>
<p>}</p>
<p>// 因为缺乏锻炼的缘故，身体强度让人担忧<br>Otaku.prototype.strength = 60;</p>
<p>Otaku.prototype.sayYourName = function () {<br>    console.log(‘I am ‘ + this.name);<br>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // 60</p>
<p>person.sayYourName(); // I am Kevin<br>例子中，可以看到，实例 person 可以：</p>
<p>访问到 Otaku 构造函数里的属性<br>访问到 Otaku.prototype 中的属性<br>模拟new:</p>
<p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：</p>
<p>function Otaku () {<br>    ……<br>}</p>
<p>// 使用 new<br>var person = new Otaku(……);<br>// 使用 objectFactory<br>var person = objectFactory(Otaku, ……)<br>初步实现<br>分析：</p>
<p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，<br>假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，<br>我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。</p>
<p>在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的__proto__属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。</p>
<p>现在，我们可以尝试着写第一版了：</p>
<p>// 第一版代码<br>function objectFactory() {</p>
<pre><code>var obj = new Object(),

Constructor = [].shift.call(arguments);

obj.__proto__ = Constructor.prototype;

Constructor.apply(obj, arguments);

return obj;</code></pre>
<p>};<br>用new Object() 的方式新建了一个对象 obj<br>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数<br>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性<br>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性<br>返回 obj<br>复制以下的代码，到浏览器中，我们可以做一下测试：</p>
<p>function Otaku (name, age) {<br>    this.name = name;<br>    this.age = age;</p>
<pre><code>this.habit = &#39;Games&#39;;</code></pre>
<p>}</p>
<p>Otaku.prototype.strength = 60;</p>
<p>Otaku.prototype.sayYourName = function () {<br>    console.log(‘I am ‘ + this.name);<br>}</p>
<p>function objectFactory() {<br>    var obj = new Object(),<br>    Constructor = [].shift.call(arguments);<br>    obj.<strong>proto</strong> = Constructor.prototype;<br>    Constructor.apply(obj, arguments);<br>    return obj;<br>};</p>
<p>var person = objectFactory(Otaku, ‘Kevin’, ‘18’)</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // 60</p>
<p>返回值效果实现<br>假如构造函数有返回值，举个例子：</p>
<p>function Otaku (name, age) {<br>    this.strength = 60;<br>    this.age = age;</p>
<pre><code>return &#123;
    name: name,
    habit: &#39;Games&#39;
&#125;</code></pre>
<p>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // undefined<br>console.log(person.age) // undefined<br>构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p>
<p>注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？</p>
<p>再举个例子：</p>
<p>function Otaku (name, age) {<br>    this.strength = 60;<br>    this.age = age;</p>
<pre><code>return &#39;handsome boy&#39;;</code></pre>
<p>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // undefined<br>console.log(person.habit) // undefined<br>console.log(person.strength) // 60<br>console.log(person.age) // 18<br>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p>
<p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p>
<p>再来看第二版的代码，也是最后一版的代码：</p>
<p>// 第二版的代码<br>function objectFactory() {</p>
<pre><code>var obj = new Object(),

Constructor = [].shift.call(arguments);

obj.__proto__ = Constructor.prototype;

var ret = Constructor.apply(obj, arguments);

return typeof ret === &#39;object&#39; ? ret : obj;</code></pre>
<p>};</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>