<!DOCTYPE html>


<html lang="en">


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Hexo
  </title>
  <meta name="generator" content="hexo-theme-ayer">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css">

  
<link rel="stylesheet" href="/css/custom.css">

  
  
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

  
  

  

</head>

</html>

<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Hexo</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-mvvm和mvc，mvp区别"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/24/mvvm%E5%92%8Cmvc%EF%BC%8Cmvp%E5%8C%BA%E5%88%AB/"
    >mvvm和mvc，mvp区别</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/24/mvvm%E5%92%8Cmvc%EF%BC%8Cmvp%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2021-01-24T13:45:16.000Z" itemprop="datePublished">2021-01-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>软件中最核心的，最基本的东西是什么? 是的，是数据。我们写的所有代码，都是围绕数据的。<br>围绕着数据的产生、修改等变化，出现了业务逻辑。<br>围绕着数据的显示，出现了不同的界面技术。 </p>
<p>没有很好设计的代码，常常就会出现数据层(持久层)和业务逻辑层还有界面代码耦合的情况。</p>
<p>ORM等框架，解耦合了业务逻辑和数据之间的耦合，业务逻辑不再关心底层数据如何存储和读取。所有数据呈现给业务逻辑层的就是一个个的对象。<br>而MVC, MVP, MMVM用来解决业务逻辑和视图之间的耦合。<br>MVC优点</p>
<p>由于MVC很好的分离了视图层和业务层，所以它具有以下优点<br>耦合性低<br>开发速度快<br>可维护性高<br>没有控件的概念，对html没有封装，易于理解<br>和其它平台(java, php)等更加相似。便于人才获取<br>MVP的优势</p>
<p>1、模型与视图完全分离，我们可以修改视图而不影响模型<br>2、可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部<br>3、我们可以将一个Presener用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁。<br>4、如果我们把逻辑放在Presenter中，那么我们就可以脱离用户界面来测试这些逻辑（单元测试）</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-原型链"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/"
    >原型链</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/24/%E5%8E%9F%E5%9E%8B%E9%93%BE/" class="article-date">
  <time datetime="2021-01-24T13:30:17.000Z" itemprop="datePublished">2021-01-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-虚拟dom是什么"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/20/%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88/"
    >虚拟dom是什么</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/20/%E8%99%9A%E6%8B%9Fdom%E6%98%AF%E4%BB%80%E4%B9%88/" class="article-date">
  <time datetime="2021-01-20T13:39:22.000Z" itemprop="datePublished">2021-01-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>  在React中，render执行的结果得到的并不是真正的DOM节点，结果仅仅是轻量级的JavaScript对象，我们称之为virtual DOM。</p>
<pre><code>    虚拟DOM是React的一大亮点，具有batching(批处理)和高效的Diff算法。这让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟 DOM来确保只对界面上真正变化的部分进行实际的DOM操作。在实际开发中基本无需关心虚拟DOM是如何运作的，但是理解其运行机制不仅有助于更好的理解React组件的生命周期，而且对于进一步优化 React程序也会有很大帮助。</code></pre>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-super关键字"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/19/super%E5%85%B3%E9%94%AE%E5%AD%97/"
    >super关键字</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/19/super%E5%85%B3%E9%94%AE%E5%AD%97/" class="article-date">
  <time datetime="2021-01-19T13:34:42.000Z" itemprop="datePublished">2021-01-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>作用：</p>
<p>1<br>super 关键字用于访问父对象上的函数。<br>语法：</p>
<p>1<br>2<br>super([arguments]); // 访问父对象上的构造函数<br>super.functionOnParent([arguments]); // 访问对象上的方法<br>详解：</p>
<p>super可以用在类的继承中，或者对象字面量中，super指代了整个prototype或者__proto__指向的对象</p>
<p>1 类（prototype相关）</p>
<p>a 用在子类constructor函数中<br> class Person {<br>    constructor (name) {<br>      this.name = name;<br>    }<br>  }<br> class Student extends Person {<br>    constructor (name, age) {<br>      super(); // 用在构造函数中，必须在使用this之前调用<br>      this.age = age;<br>   }<br> }<br> super()调用会生成一个空对象，作为context来调用父类的constructor，返回this对象，作为子类constructor的context继续调用构造函数。</p>
<p>context：执行上下文 constructor：构造函数<br>b 调用父类的静态函数<br>class Human {<br>    constructor() {}<br>    static ping() {<br>      return ‘ping’;<br>    }<br>  }</p>
<p>  class Computer extends Human {<br>    constructor() {}<br>   static pingpong() {<br>     return super.ping() + ‘ pong’;<br>   } // 只有在子类的静态函数中才能调用父类的静态函数（babel环境测试，按理说，在实例函数中应该也可以调用，不过实际测试环境中报错）<br> }<br> Computer.pingpong(); // ‘ping pong’</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-key的作用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/key%E7%9A%84%E4%BD%9C%E7%94%A8/"
    >key的作用</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/key%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2021-01-17T15:35:33.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>key 的特殊 attribute 主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</p>
<p>有相同父元素的子元素必须有独特的 key。重复的 key 会造成渲染错误。</p>
<p>最常见的是结合 v-for 使用</p>
<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用：</p>
<p>完整地触发组件的生命周期钩子<br>触发过渡<br><transition><br>    <span :key="text"></span><br></transition><br>当text发生改变时，<span>总是会被替换而不是被修改，因此会引发过渡</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-TCP和UDP"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/TCP%E5%92%8CUDP/"
    >TCP和UDP</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/TCP%E5%92%8CUDP/" class="article-date">
  <time datetime="2021-01-17T15:30:34.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>TCP/IP 是互联网相关的各类协议族的总称，比如：TCP，UDP，IP，FTP，HTTP，ICMP，SMTP 等都属于 TCP/IP 族内的协议。</p>
<p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<p>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。<br>网络层：负责路由以及把分组报文发送给目标网络或主机。<br>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。<br>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</p>
<p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h1 id="UDP-是什么？"><a href="#UDP-是什么？" class="headerlink" title="UDP 是什么？"></a>UDP 是什么？</h1><p>UDP协议全称是用户数据报协议，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在第四层——传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<h1 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h1><p>（1）TCP 是面向连接的，udp 是无连接的即发送数据前不需要先建立链接。</p>
<p>（2）TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。 并且因为 tcp 可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>
<p>（3）TCP 是面向字节流，UDP 面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如 IP 电话和视频会议等）。</p>
<p>（4）TCP 只能是 1 对 1 的，UDP 支持 1 对 1,1 对多。</p>
<p>（5）TCP 的首部较大为 20 字节，而 UDP 只有 8 字节。</p>
<p>（6）TCP 是面向连接的可靠性传输，而 UDP 是不可靠的。</p>
<h1 id="Post-author-￢-￢-智商三岁-￢-￢-智商三岁"><a href="#Post-author-￢-￢-智商三岁-￢-￢-智商三岁" class="headerlink" title="Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁"></a>Post author: (￢_￢)智商三岁 @(￢_￢)智商三岁</h1><h1 id="Post-link-http-example-com-2021-01-13-TCP和UDP以及三次握手"><a href="#Post-link-http-example-com-2021-01-13-TCP和UDP以及三次握手" class="headerlink" title="Post link: http://example.com/2021/01/13/TCP和UDP以及三次握手/"></a>Post link: <a href="http://example.com/2021/01/13/TCP%E5%92%8CUDP%E4%BB%A5%E5%8F%8A%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/">http://example.com/2021/01/13/TCP和UDP以及三次握手/</a></h1><h1 id="Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally"><a href="#Copyright-Notice-All-articles-in-this-blog-are-licensed-under-CC-BY-NC-SA-unless-stating-additionally" class="headerlink" title="Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally."></a>Copyright Notice: All articles in this blog are licensed under (CC)BY-NC-SA unless stating additionally.</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。<br>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为<br>对数据准确性要求高，速度可以相对较慢的，可以选用TCP</p>
<h1 id="TCP-提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用-4-次握手来关闭一个连接。"><a href="#TCP-提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用-4-次握手来关闭一个连接。" class="headerlink" title="TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次握手来关闭一个连接。"></a>TCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用 4 次握手来关闭一个连接。</h1><h1 id="三次握手建立一个连接"><a href="#三次握手建立一个连接" class="headerlink" title="三次握手建立一个连接"></a>三次握手建立一个连接</h1><p>三次握手的过程:</p>
<p>第一次握手</p>
<p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。<br>第二次握手</p>
<p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。<br>第三次握手</p>
<p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>这里可能大家会有个疑惑：为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</p>
<h1 id="四次握手关闭一个连接"><a href="#四次握手关闭一个连接" class="headerlink" title="四次握手关闭一个连接"></a>四次握手关闭一个连接</h1><p>第一次握手</p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。<br>第二次握手</p>
<p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双向的，所以 B 仍旧可以发送数据给 A。<br>第三次握手</p>
<p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。<br>第四次握手</p>
<p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-new"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/17/new/"
    >new</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/17/new/" class="article-date">
  <time datetime="2021-01-17T15:24:34.000Z" itemprop="datePublished">2021-01-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>new<br>JavaScript深入之new的模拟实现</p>
<p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一</p>
<p>模拟 new 之前，先看看 new 实现了哪些功能。<br>例子：</p>
<p>// Otaku 御宅族，简称宅<br>function Otaku (name, age) {<br>    this.name = name;<br>    this.age = age;</p>
<pre><code>this.habit = &#39;Games&#39;;</code></pre>
<p>}</p>
<p>// 因为缺乏锻炼的缘故，身体强度让人担忧<br>Otaku.prototype.strength = 60;</p>
<p>Otaku.prototype.sayYourName = function () {<br>    console.log(‘I am ‘ + this.name);<br>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // 60</p>
<p>person.sayYourName(); // I am Kevin<br>例子中，可以看到，实例 person 可以：</p>
<p>访问到 Otaku 构造函数里的属性<br>访问到 Otaku.prototype 中的属性<br>模拟new:</p>
<p>因为 new 是关键字，所以无法像 bind 函数一样直接覆盖，所以我们写一个函数，命名为 objectFactory，来模拟 new 的效果。用的时候是这样的：</p>
<p>function Otaku () {<br>    ……<br>}</p>
<p>// 使用 new<br>var person = new Otaku(……);<br>// 使用 objectFactory<br>var person = objectFactory(Otaku, ……)<br>初步实现<br>分析：</p>
<p>因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，<br>假设这个对象叫 obj，因为 obj 会具有 Otaku 构造函数里的属性，想想经典继承的例子，<br>我们可以使用 Otaku.apply(obj, arguments)来给 obj 添加新的属性。</p>
<p>在 JavaScript 深入系列第一篇中，我们便讲了原型与原型链，我们知道实例的__proto__属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。</p>
<p>现在，我们可以尝试着写第一版了：</p>
<p>// 第一版代码<br>function objectFactory() {</p>
<pre><code>var obj = new Object(),

Constructor = [].shift.call(arguments);

obj.__proto__ = Constructor.prototype;

Constructor.apply(obj, arguments);

return obj;</code></pre>
<p>};<br>用new Object() 的方式新建了一个对象 obj<br>取出第一个参数，就是我们要传入的构造函数。此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数<br>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性<br>使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性<br>返回 obj<br>复制以下的代码，到浏览器中，我们可以做一下测试：</p>
<p>function Otaku (name, age) {<br>    this.name = name;<br>    this.age = age;</p>
<pre><code>this.habit = &#39;Games&#39;;</code></pre>
<p>}</p>
<p>Otaku.prototype.strength = 60;</p>
<p>Otaku.prototype.sayYourName = function () {<br>    console.log(‘I am ‘ + this.name);<br>}</p>
<p>function objectFactory() {<br>    var obj = new Object(),<br>    Constructor = [].shift.call(arguments);<br>    obj.<strong>proto</strong> = Constructor.prototype;<br>    Constructor.apply(obj, arguments);<br>    return obj;<br>};</p>
<p>var person = objectFactory(Otaku, ‘Kevin’, ‘18’)</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // 60</p>
<p>返回值效果实现<br>假如构造函数有返回值，举个例子：</p>
<p>function Otaku (name, age) {<br>    this.strength = 60;<br>    this.age = age;</p>
<pre><code>return &#123;
    name: name,
    habit: &#39;Games&#39;
&#125;</code></pre>
<p>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // Kevin<br>console.log(person.habit) // Games<br>console.log(person.strength) // undefined<br>console.log(person.age) // undefined<br>构造函数返回了一个对象，在实例 person 中只能访问返回的对象中的属性。</p>
<p>注意一点，在这里我们是返回了一个对象，假如我们只是返回一个基本类型的值呢？</p>
<p>再举个例子：</p>
<p>function Otaku (name, age) {<br>    this.strength = 60;<br>    this.age = age;</p>
<pre><code>return &#39;handsome boy&#39;;</code></pre>
<p>}</p>
<p>var person = new Otaku(‘Kevin’, ‘18’);</p>
<p>console.log(person.name) // undefined<br>console.log(person.habit) // undefined<br>console.log(person.strength) // 60<br>console.log(person.age) // 18<br>结果完全颠倒过来，这次尽管有返回值，但是相当于没有返回值进行处理。</p>
<p>所以我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么。</p>
<p>再来看第二版的代码，也是最后一版的代码：</p>
<p>// 第二版的代码<br>function objectFactory() {</p>
<pre><code>var obj = new Object(),

Constructor = [].shift.call(arguments);

obj.__proto__ = Constructor.prototype;

var ret = Constructor.apply(obj, arguments);

return typeof ret === &#39;object&#39; ? ret : obj;</code></pre>
<p>};</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-回流和重绘"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/12/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"
    >回流和重绘</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/12/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/" class="article-date">
  <time datetime="2021-01-12T12:28:54.000Z" itemprop="datePublished">2021-01-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
   
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-ts的六个类型"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/03/ts%E7%9A%84%E5%85%AD%E4%B8%AA%E7%B1%BB%E5%9E%8B/"
    >ts的六个类型</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/03/ts%E7%9A%84%E5%85%AD%E4%B8%AA%E7%B1%BB%E5%9E%8B/" class="article-date">
  <time datetime="2021-01-03T12:59:02.000Z" itemprop="datePublished">2021-01-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h4 id="1-布尔值"><a href="#1-布尔值" class="headerlink" title="1.布尔值"></a>1.布尔值</h4><p>编译前:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let flag:boolean &#x3D; true</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var flag &#x3D; true;</span><br></pre></td></tr></table></figure>
<h4 id="2-数字"><a href="#2-数字" class="headerlink" title="2.数字"></a>2.数字</h4><p>编译前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let num:number &#x3D; 123</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 123;</span><br></pre></td></tr></table></figure>
<h4 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h4><p>编译前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let name1:string &#x3D; &#39;哈哈&#39;</span><br><span class="line">name1 &#x3D; &#39;路飞&#39;</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var name1 &#x3D; &#39;哈哈&#39;;</span><br><span class="line">name1 &#x3D; &#39;路飞&#39;;</span><br></pre></td></tr></table></figure>
<h4 id="4-数组"><a href="#4-数组" class="headerlink" title="4.数组"></a>4.数组</h4><blockquote>
<p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组，第二种方式是使用数组泛型，Array&lt;元素类型&gt;：</p>
</blockquote>
<p>编译前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let list:string[] &#x3D; [&quot;hello&quot;,&quot;hi&quot;]  &#x2F;&#x2F;数组类型且里面的值为字符串</span><br><span class="line">let list2:Array&lt;number&gt; &#x3D; [1,2]    &#x2F;&#x2F;数组泛型&#x3D;&#x3D;&gt;Array&lt;元素类型&gt;</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var list &#x3D; [&quot;hello&quot;, &quot;hi&quot;]; &#x2F;&#x2F;数组类型且里面的值为字符串</span><br><span class="line">var list2 &#x3D; [1, 2]; &#x2F;&#x2F;数组泛型&#x3D;&#x3D;&gt;Array&lt;元素类型&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-元组"><a href="#5-元组" class="headerlink" title="5.元组"></a>5.元组</h4><blockquote>
<p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。</p>
</blockquote>
<p>编译前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let all:[number,string] &#x3D; [1,&#39;hello&#39;]  &#x2F;&#x2F;元组类型</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var all &#x3D; [1, &#39;hello&#39;]; &#x2F;&#x2F;元组类型</span><br></pre></td></tr></table></figure>
<h4 id="6-枚举"><a href="#6-枚举" class="headerlink" title="6.枚举"></a>6.枚举</h4><blockquote>
<p>enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
</blockquote>
<p>编译前：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;Red, Green, Blue&#125; &#x2F;&#x2F;枚举</span><br><span class="line">let c: Color &#x3D; Color.Green;</span><br></pre></td></tr></table></figure>
<p>编译后:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Color;</span><br><span class="line">(function (Color) &#123;</span><br><span class="line">    Color[Color[&quot;Red&quot;] &#x3D; 0] &#x3D; &quot;Red&quot;;</span><br><span class="line">    Color[Color[&quot;Green&quot;] &#x3D; 1] &#x3D; &quot;Green&quot;;</span><br><span class="line">    Color[Color[&quot;Blue&quot;] &#x3D; 2] &#x3D; &quot;Blue&quot;;</span><br><span class="line">&#125;)(Color || (Color &#x3D; &#123;&#125;)); &#x2F;&#x2F;枚举</span><br><span class="line">var c &#x3D; Color.Green;</span><br></pre></td></tr></table></figure> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-属性描述符"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/03/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/"
    >属性描述符</a> 
</h2>
 

    </header>
     
    <div class="article-meta">
      <a href="/2021/01/03/%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6/" class="article-date">
  <time datetime="2021-01-03T12:55:48.000Z" itemprop="datePublished">2021-01-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Object.defineProperty<br>Object.defineProperty(obj,prop,desctiptor)接受3个参数。<br>obj:接受一个对象、prop:定义或修改的属性或Smybol、descriptor:属性描述符</p>
<p> let obj ={<br>    name:’hello’<br>}<br>Object.defineProperty(obj,’sex’,{value:’world’})<br>console.log(Object.keys(obj))<br>//只拿到了name 因为用上面定义的方法给对象添加的属性是不可枚举的所以它并不能被拿到<br>对象里目前存在属性描述符有两种主要形式：数据描述符合存取描述符。<br>数据描述符是一个具有值的属性，该值可以是可写的，也可以是不可写的。<br>存取描述符是由getter函数和setter函数所描述的属性。一个描述符只能是这两种其中之一，不能同时是两者<br>这两种描述符都是对象。他们共享一下可选键值(默认值是指咋使用Object.definPropety()定义属性时的默认值)<br>configurable<br>当且仅当该属性的 configurable 键值为 true 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。<br>默认为 false。<br>enumerable<br>当且仅当该属性的 enumerable 键值为 true 时，该属性才会出现在对象的枚举属性中。<br>默认为 false。<br>数据描述符还具有以下可选键值：</p>
<p>value<br>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。<br>默认为 undefined。<br>writable<br>当且仅当该属性的 writable 键值为 true 时，属性的值，也就是上面的 value，才能被赋值运算符改变。<br>默认为 false。<br>存取描述符还具有以下可选键值：</p>
<p>get<br>属性的 getter 函数，如果没有 getter，则为 undefined。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 this 对象（由于继承关系，这里的this并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。<br>默认为 undefined。<br>set<br>属性的 setter 函数，如果没有 setter，则为 undefined。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 this 对象。<br>默认为 undefined。<br>var o = {}; // 创建一个新对象</p>
<p>// 在对象中添加一个属性与数据描述符的示例<br>Object.defineProperty(o, “a”, {<br>  value : 37,<br>  writable : true,<br>  enumerable : true,<br>  configurable : true<br>});</p>
<p>// 对象 o 拥有了属性 a，值为 37</p>
<p>// 在对象中添加一个设置了存取描述符属性的示例<br>var bValue = 38;<br>Object.defineProperty(o, “b”, {<br>  // 使用了方法名称缩写（ES2015 特性）<br>  // 下面两个缩写等价于：<br>  // get : function() { return bValue; },<br>  // set : function(newValue) { bValue = newValue; },<br>  get() { return bValue; },<br>  set(newValue) { bValue = newValue; },<br>  enumerable : true,<br>  configurable : true<br>});</p>
<p>o.b; // 38<br>// 对象 o 拥有了属性 b，值为 38<br>// 现在，除非重新定义 o.b，o.b 的值总是与 bValue 相同</p>
<p>// 数据描述符和存取描述符不能混合使用<br>Object.defineProperty(o, “conflict”, {<br>  value: 0x9f91102,<br>  get() { return 0xdeadbeef; }<br>});<br>// 抛出错误 TypeError: value appears only in data descriptors, get appears only in accessor descriptors</p>
<p>自定义 Setters 和 Getters<br>下面的例子展示了如何实现一个自存档对象。当设置temperature 属性时，archive 数组会收到日志条目。</p>
<p>function Archiver() {<br>  var temperature = null;<br>  var archive = [];</p>
<p>  Object.defineProperty(this, ‘temperature’, {<br>    get: function() {<br>      console.log(‘get!’);<br>      return temperature;<br>    },<br>    set: function(value) {<br>      temperature = value;<br>      archive.push({ val: temperature });<br>    }<br>  });</p>
<p>  this.getArchive = function() { return archive; };<br>}</p>
<p>var arc = new Archiver();<br>arc.temperature; // ‘get!’<br>arc.temperature = 11;<br>arc.temperature = 13;<br>arc.getArchive(); // [{ val: 11 }, { val: 13 }]</p>
<p>继承属性<br>如果访问者的属性是被继承的，它的 get 和 set 方法会在子对象的属性被访问或者修改时被调用。如果这些方法用一个变量存值，该值会被所有对象共享。</p>
<p>function myclass() {<br>}</p>
<p>var value;<br>Object.defineProperty(myclass.prototype, “x”, {<br>  get() {<br>    return value;<br>  },<br>  set(x) {<br>    value = x;<br>  }<br>});</p>
<p>var a = new myclass();<br>var b = new myclass();<br>a.x = 1;<br>console.log(b.x); // 1<br>Object.assign()<br>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p>
<p>let obj1 = {<br>    name:’hong’,<br>    sex:’女’<br>}<br>let obj2 = {<br>    age:’18’,<br>    get sayName(){<br>        return ‘hong’<br>    }<br>}<br>let obj3 = Object.assign({},obj1,obj2)<br>console.log(obj3)//此时合并完，就会把obj2里的存取属性给变成了数据属性<br>//应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。<br>异常会打断后续拷贝任务</p>
<p>const target = Object.defineProperty({}, “foo”, {<br>    value: 1,<br>    writable: false<br>}); // target 的 foo 属性是个只读属性。</p>
<p>Object.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});<br>// TypeError: “foo” is read-only<br>// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</p>
<p>console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。<br>console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。<br>console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。<br>console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。<br>console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。<br>拷贝访问器(手动实现你原来是个存取属性，现在通过Object.assign()拷贝过来还是存取属性)<br>const obj = {<br>  foo: 1,<br>  get bar() {<br>    return 2;<br>  }<br>};</p>
<p>let copy = Object.assign({}, obj);<br>console.log(copy); // { foo: 1, bar: 2 } copy.bar的值来自obj.bar的getter函数的返回值</p>
<p>// 下面这个函数会拷贝所有自有属性的属性描述符<br>function completeAssign(target, …sources) {<br>  sources.forEach(source =&gt; {<br>    let descriptors = Object.keys(source).reduce((descriptors, key) =&gt; {<br>      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);<br>      return descriptors;<br>    }, {});</p>
<pre><code>// Object.assign 默认也会拷贝可枚举的Symbols
Object.getOwnPropertySymbols(source).forEach(sym =&gt; &#123;
  let descriptor = Object.getOwnPropertyDescriptor(source, sym);
  if (descriptor.enumerable) &#123;
    descriptors[sym] = descriptor;
  &#125;
&#125;);
Object.defineProperties(target, descriptors);</code></pre>
<p>  });<br>  return target;<br>}</p>
<p>copy = completeAssign({}, obj);<br>console.log(copy);<br>// { foo:1, get bar() { return 2 } }</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
        
        
        Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
        <span class="division">|</span>
        Theme - <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></s>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Hexo"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://shenyu-vip.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->

<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>

<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->


<script src="/js/busuanzi-2.3.pure.min.js"></script>


<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->


<link rel="stylesheet" href="/css/clipboard.css">

<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>


<!-- CanvasBackground -->


    
  </div>
</body>

</html>